//nome: CATALIN COVALI
#include <iostream>
#include <vector>
#include <stdexcept>
#include <string>
#include <cmath>
#include <memory>
#include "DeviceManager.h"
#include "Device.h"
#include "Time.h"


// Constructor that initializes the power limit and current power usage.
// If maxPower is not provided, the default value is 3.5 kW.
DeviceManager::DeviceManager(double maxPower) : powerLimit{maxPower}, powerUsage{0.0} {
  if (maxPower < 0)
    throw std::invalid_argument("[ERROR] Maximum power limit cannot be negative.");
}



// Adds a device to the list if its power consumption is within limits.
void DeviceManager::addDevice(std::shared_ptr<Device> d) {
  if(d->getPowerConsumption() < 0 && fabs(d->getPowerConsumption()) > powerLimit) {
    std::cerr << "[ERROR] Unable to add device '" << d->getName()
              << "'. Power consumption (" << d->getPowerConsumption()
              << " kW) exceeds the maximum allowable limit of " << powerLimit
              << " kW.\n";
    return;
  }

  devices.push_back(d);
}



// This method ensures that if the maximum threshold is exceeded
// devices are turned off according to the defined policy
void DeviceManager::addToActiveDevices(std::shared_ptr<Device> d) {
  // If the device should remain plugged or produces energy, add it at the beginning of the activeDevices list
  if (d->getKeepDevicePlugged() && d->getPowerConsumed() > 0)
    activeDevices.insert( activeDevices.begin(), d );
  // Else add it at the end of active devices list
  activeDevices.push_back(d);
}



// Simulates the passage of time and updates the state of devices, turning them on or off
// Enforces the power limit policy by turning off the most recently turned-on device.
// Removes the device from the active devices list, turns it off, and returns its name.
std::string DeviceManager::powerLimitPolicy() {
  if(activeDevices.empty())
    throw std::runtime_error("[ERROR] No active devices to turn off to enforce the power limit.");

  std::shared_ptr<Device> lastDeviceTurnedOn = activeDevices.back();
  activeDevices.pop_back();
  DeviceManager::turnOffDevice(lastDeviceTurnedOn);

}



// Calculates the power consumed by the device based on the time it has been ON.
void DeviceManager::updatePowerUsage(std::shared_ptr<Device> d) {
  // If device is off kWh might be already been refresh or 0
  if (!d->isOn())
    return;

  // Calculate the time the device has been on
  double timeBeingON = currentTime - d->getStart();
  // Convert time to hours and calculate the power consumed in kWh
  double newValue = timeBeingON.toMinutes() / 60 * d->getPowerConsumption();

  d->updatePowerConsumed(newValue);
}



// Updates kWh on the device and returns it
double DeviceManager::getDeviceUsage(std::shared_ptr<Device> d) {
  DeviceManager::updateDeviceUsage(d);
  return d->getPowerConsumed();
}



// Returns the total power generated by the system, including power from the limit
// and devices that produce power.
double getGeneratedPower() {
  double powerProduced = currentTime.toMinutes() / 60 * powerLimit;
  // Adds the power produced by devices that generate energy.
  for (auto& device : devices)
    if (device->getPowerConsumption() > 0)
      powerProduced += DeviceManager::getDeviceUsage(device);

  return powerProduced;
}



// Returns the total power consumption of active devices
double DeviceManager::getPowerUsage() const {
  powerUsage = 0.0;

  for (const auto& device : devices)
    if (device -> isOn() && device->getPowerConsumption() < 0)
      powerUsage += DeviceManager::getDeviceUsage(device);

  return fabs(powerUsage);
}


// Returns a vector of device names and their corresponding power usage.
std::vector<std::string> getAllDevicesUsage() {
  std::vector<std::string> output;

  for (auto& device : devices) {
    output.push_back(device->getName());  // Add device NAME
    output.push_back(DeviceManager::getDeviceUsage(device));  // Add device power usage kWh
  }
  return output;
}



// Turns on the device, turning off others if needed to stay within the power limit.
// Returns a vector of names: the last is the turned-on device, others were turned off.
std::vector<std::string> DeviceManager::turnOnDevice(std::shared_ptr<Device> d){
  std::vector<std::string> output;

  // Turn off devices until the total power usage is within the limit
  while (d->getPowerConsumption() + DeviceManager::getPowerUsage() > powerLimit)
    output.push_back( DeviceManager::powerLimitPolicy() );// Turn off a device and save its name

  DeviceManager::addToActiveDevices(d);
  d->turnOn();

  // Add the name of the newly turned-on device to the output vector
  output.push_back( d->getName() );
  return output;
}





// Turns off a device if it is on. Removes it from the active devices list
// and updates the power consumption accordingly
void DeviceManager::turnOffDevice(std::shared_ptr<Device> d){
  /* Check if device is already OFF
  if (!d->isOn()) {
    std::cout << " Il dispositivo '" << d->getName() << "è già spento\n";
    return;
  }
  */

  // Remove device from active devices list
  auto it = std::find(activeDevices.begin(), activeDevices.end(), d);
  if (it != activeDevices.end())
    activeDevices.erase(it);

  DeviceManager::refreshPowerUsage(d);
  d->turnOff();
}



void DeviceManager::setStartTimer(std::shared_ptr<Device> d, Time time) {
  d->setStartTime(time);
}



void DeviceManager::setEndTimer(std::shared_ptr<Device> d, Time time) {
  d->setFinishTime(time);
}


// Invalidating any start or end times
void DeviceManager::removeTimer(std::shared_ptr<Device> d) {
  d->invalidateTime();
}





// Finds and returns the device with the given name
std::shared_ptr<Device> DeviceManager::findDeviceByName(const std::string& name) const{
  for (auto& device : devices)
    if (device->getName() == name)
      return device;

  std::cout << " [ERROR] Device '" << name << "' not found.\n";
  return nullptr;
}


















// based on their timers
void DeviceManager::setTime(Time time) {
  if(time < currentTime)
    throw std::invalid_argument("[ERROR] Non si puo tornare indietro nel tempo");

  while (currentTime != time) {
    currentTime.increment();
    // Check each device for scheduled start/finish times and turns it on or off accordingly
    for (const auto& device : devices){
      if (device->getStartTime() == currentTime && device->isTimerValid())
        DeviceManager::turnOnDevice(device);

      if (device->getFinishTime() == currentTime && device->isTimerValid())
        DeviceManager::turnOffDevice(device);
    }
  }
}



// For debugging: resets the time and turns off all devices.
void DeviceManager::resetTime(){
  for (auto& device : devices)
    device -> turnOff();
  currentTime(0,0);
}

// For debugging: invalidates all device timers.
void DeviceManager::resetTimers(){
  for (const auto& device : devices)
    device -> invalidateTimer();
}

// Resets both the time and all timers, returning the system to an initial state.
void DeviceManager::resetAll(){
  DeviceManager::resetTime();
  DeviceManager::resetTimers();
}

